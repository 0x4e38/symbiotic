#!/usr/bin/env python

import sys
import os
import re
import getopt
import signal
from subprocess import call, Popen, PIPE, STDOUT

VERSION='2.ns-alpha'

usage_msg = """
Usage: symbiotic [--64 | --timeout=t | --no-slice | --sv-comp | --prp=property | --debug=what] source

    --64              Use 64-bit environment
    --timeout=t       Set timeout to t seconds
    --no-slice        Do not slice the code
    --require-slicer  Abort if slicing fails (default is to use the original file)
    --sv-comp         Give output in sv-comp format (FALSE, TRUE, UNKNOWN)
    --prp=property    Specify property that should hold. Relevant only with sv-comp atm.
    --debug=what      Print debug messages, what can be comma separated list of: all, compile, prepare, slicer
                      In that case you get verbose output. You can just use --debug= to print basic messages.
"""

# define and compile regular expressions for parsing klee's output
patterns = {
    'ASSERTIONFAILED' : re.compile('.*ASSERTION FAIL: verifier assertion failed.*'),
    'ESTPTIMEOUT' : re.compile('.*query timed out (resolve).*'),
    'EKLEETIMEOUT' : re.compile('.*HaltTimer invoked.*'),
    'EEXTENCALL' : re.compile('.*failed external call.*'),
    'ELOADSYM' : re.compile('.*ERROR: unable to load symbol.*'),
    'EINVALINST' : re.compile('.*LLVM ERROR: Code generator does not support.*'),
    'EKLEEASSERT' : re.compile('.*klee: .*Assertion .* failed.*'),
    'EINITVALS' : re.compile('.*unable to compute initial values.*'),
    'ESYMSOL' : re.compile('.*unable to get symbolic solution.*'),
    'ESLIENTLYCONCRETIZED' : re.compile('.*silently concretizing.*'),
    'EEXTRAARGS' : re.compile('.*calling .* with extra arguments.*'),
    'EABORT' : re.compile('.*abort failure.*'),
    'EGENERAL' : re.compile('.*now ignoring this error at this location.*'),
    'ESKIPFORK' : re.compile('.*skipping fork.*'),
    'EKILLSTATE' : re.compile('.*killing.*states (over memory cap).*')
}

supported_properties = {
    'REACHCALL'  : 'CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )'
}

unsupported_call = re.compile('.*call to .* is unsupported.*')

enable_debug = False
debug_opts = []
# this is global variable for currently running
# klee process, so that we can kill it if we need
# (e. g. on timeout)
current_process = None

def parse_debug_opts(opts):
    global debug_opts
    debug_opts = opts.split(',')

class Timeout(Exception):
    pass

def start_timeout(sec):
    def alarm_handler(signum, data):
        raise Timeout

    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(sec)

def stop_timeout():
    # turn of timeout
    signal.signal(signal.SIGALRM, signal.SIG_DFL)
    signal.alarm(0)

def run_and_watch(cmd, watch):
    dbg(' '.join(cmd))
    global current_process
    current_process = Popen(cmd, stdout=PIPE, stderr=STDOUT)

    while True:
        line = current_process.stdout.readline()
        if line == '' and current_process.poll() is not None:
            break

        if not watch(line):
            current_process.terminate()
            current_process.kill()
            return -1

    current_process.wait()
    return current_process.returncode

def get_match(line):
    for (key, pattern) in patterns.iteritems():
        if pattern.match(line):
            # return True so that we know we should terminate
            if key == 'ASSERTIONFAILED':
                return (key, True)
            else:
                return (key, False)

    return (None, False)

def print_stderr(msg, prefix = None, print_nl = True):
    """
    Print message to stderr

    @ msg     : str    message to print
    @ prefix  : str    prefix for the message
    @print_nl : bool   print new line after the message
    """

    if msg == '':
        return
    if not prefix is None:
        sys.stderr.write(prefix)

    sys.stderr.write(msg)
    if print_nl:
        sys.stderr.write('\n')

    sys.stderr.flush()

def err(msg):
    print_stderr(msg, 'ERROR: ')
    sys.exit(1)

def dbg(msg, domain = 'all', print_nl = True):
    if enable_debug:
        global debug_opts
        if domain == 'all' or domain in debug_opts:
            print_stderr(msg, 'DBG: ', print_nl)

def get_symbiotic_dir():
    return os.path.abspath(os.path.dirname(sys.argv[0]))

def set_environ(is32bit = False):
    def prepend(env, what):
        if os.environ.has_key(env):
            newenv = '{0}:{1}'.format(what, os.environ[env])
        else:
            newenv = what

        os.environ[env] = newenv

    symbiotic_dir = get_symbiotic_dir()
    # set path without preprending, we want to use only our stuff
    os.environ['PATH'] = '{0}/bin'.format(symbiotic_dir)
    prepend('LD_LIBRARY_PATH', '{0}/lib'.format(symbiotic_dir))
    prepend('C_INCLUDE_DIR', '{0}/include'.format(symbiotic_dir))
    if is32bit:
        prepend('KLEE_RUNTIME_LIBRARY_PATH',
                '{0}/lib32/klee/runtime'.format(symbiotic_dir))
    else:
        prepend('KLEE_RUNTIME_LIBRARY_PATH',
                '{0}/lib/klee/runtime'.format(symbiotic_dir))

    dbg('PATH: {0}'.format(os.environ['PATH']))
    dbg('LD_LIBRARY_PATH: {0}'.format(os.environ['LD_LIBRARY_PATH']))

def dbg_watch(l, dbgdomain = 'all'):
    dbg(l, domain = dbgdomain, print_nl = False)
    return True

def compile_to_llvm(source, is32bit = False, output = None):
    symbiotic_dir = get_symbiotic_dir()

    cmd = ['clang', '-c', '-emit-llvm', '-I']
    cmd.append('{0}/include'.format(symbiotic_dir))

    if is32bit:
        cmd.append('-m32')

    cmd.append('-o')
    if output is None:
        llvmfile = '{0}.bc'.format(source[:source.rfind('.')])
    else:
        llvmfile = output

    cmd.append(llvmfile)
    cmd.append(source)

    if run_and_watch(cmd, lambda l: dbg_watch(l, 'compile')) != 0:
        return None

    return llvmfile

def get_libraries(is32bit = False, add_libc = True):
    symbiotic_dir = get_symbiotic_dir()

    d = '{0}/lib'.format(symbiotic_dir)
    if is32bit:
        d += '32'

    libc = '{0}/lib.c'.format(symbiotic_dir)
    llvmlibbc = compile_to_llvm(libc, is32bit)
    if llvmlibbc is None:
        return []

    files = [llvmlibbc]
    if add_libc:
        files.append('{0}/klee/runtime/klee-libc.bc'.format(d))

    return files

def check_llvmfile(llvmfile):
    def unsupp_watch(line):
        dbg(line, domain='prepare', print_nl = False)
        return not unsupported_call.match(line)

    cmd = ['opt', '-load', 'LLVMsvc15.so', '-check-unsupported',
           '-o', '/dev/null', llvmfile]
    if run_and_watch(cmd, unsupp_watch) == -1:
        return False

    return True

def run_symexe(llvmfile):
    def parse_klee_output(line):
        dbg(line, print_nl = False)
        return get_match(line)

    cmd = ['klee', '-optimize', '-write-paths', llvmfile]
    dbg(str(cmd))

    global current_process
    current_process = Popen(cmd, stdout=PIPE, stderr=STDOUT)

    found = ''
    while True:
        line = current_process.stdout.readline()
        if line == '' and current_process.poll() is not None:
            break

        nxt, done = parse_klee_output(line)

        if done:
            # send klee the sigint, so that it
            # will stop running and dump the traces
            current_process.send_signal(2)
            #current_process.terminate()
            #current_process.kill()
            found = nxt
            break
        elif not nxt is None:
            found += '{0} '.format(nxt)

    current_process.wait()
    return found

def report_results(res, svcomp):
    dbg(res)
    result = res

    if svcomp:
        if res.startswith('ASSERTIONFAILED'):
            result = 'FALSE'
        elif res == '':
            result = 'TRUE'
        elif res == 'TIMEOUT':
            result = 'TIMEOUT'
        else:
            result = 'UNKNOWN'

    print(result)
    sys.stdout.flush()

    return result

class SymbioticException(Exception):
    def __init__(self, msg):
        Exception.__init__(self, msg)

class SymbioticOptions(object):
    def __init__(self, is32bit = True, noslice=False, prp=None, svcomp = False, timeout=0):
        self.is32bit = is32bit
        self.prp = prp
        self.noslice = noslice
        self.svcomp = svcomp
        self.timeout = 0
        self.add_libc = False
        self.old_slicer = False
        self.require_slicer = False

class Symbiotic(object):
    """
    Instance of symbiotic tool. Instruments, prepares, compiles and runs
    symbolic execution on given source
    """
    def __init__(self, src, opts = None):
        # source file
        self.source = src
        # source compiled to llvm bytecode
        self.llvmfile = None
        # libraries to be linked to the llvm file
        self.libs = []
        # the file that will be used for symbolic execution
        self.runfile = None

        if opts is None:
            self.options = SymbioticOptions()
        else:
            self.options = opts

    def instrument(self):
        """
        Instrument the code. This writes right into the file we got
        """
        sd = get_symbiotic_dir()
        cmd = ['/bin/sh', '-c', '{0}/build-fix.sh {1}'.format(sd, self.source)]
        if run_and_watch(cmd, dbg_watch) != 0:
            raise SymbioticException('Failed instrumenting the code')

    def prepare(self):
        output = '{0}-prepared.bc'.format(self.llvmfile[:self.llvmfile.rfind('.')])
        cmd = ['opt', '-load', 'LLVMsvc15.so', '-prepare', '-delete-undefined',
               self.llvmfile, '-o', output]

        if run_and_watch(cmd, lambda l: dbg_watch(l, 'prepare')) != 0:
            raise SymbioticException('Prepare phase failed')

        self.llvmfile = output

    def link(self):
        if not self.libs:
            return

        output = '{0}-linked.bc'.format(self.llvmfile[:self.llvmfile.rfind('.')])
        cmd = ['llvm-link', self.llvmfile, '-o', output] + self.libs

        if run_and_watch(cmd, lambda l: dbg_watch(l, 'compile')) != 0:
            raise SymbioticException('Failed linking llvm file with libraries')

        self.llvmfile = output

    def slicer(self, criterion):
        output = '{0}.sliced'.format(self.llvmfile[:self.llvmfile.rfind('.')])
        if self.options.old_slicer:
            cmd = ['opt', '-load', 'LLVMSlicer.so', '-simplifycfg', '-create-hammock-cfg',
                   '-slice-inter', '-simplifycfg', '-o', output, self.llvmfile]
        else:
            cmd = ['llvm-slicer', '-c', criterion, self.llvmfile]

        if run_and_watch(cmd, lambda l: dbg_watch(l, 'slicer')) != 0:
            raise SymbioticException('Slicing failed')

        self.llvmfile = output

    def optimize(self, passes = ['-simplifycfg', '-dce']):
        output = '{0}-optimized.bc'.format(self.llvmfile[:self.llvmfile.rfind('.')])
        cmd = ['opt', '-o', output, self.llvmfile] + passes

        if run_and_watch(cmd, lambda l: dbg_watch(l, 'slicer')) != 0:
            raise SymbioticException('Optimizing the code failed')

        self.llvmfile = output

    def run(self, criterion = '__assert_fail'):
        try:
            self.instrument()

            # set environ here, because in instrumentation we use
            # grep and similar commands
            # FIXME rewrite instrumentation here
            set_environ(opts.is32bit)

            # FIXME do next two phases more "pure"
            self.llvmfile = compile_to_llvm(self.source, self.options.is32bit)
            if self.llvmfile is None:
                err('Failed compiling the source {0}'.format(self.source))

            if not check_llvmfile(self.llvmfile):
                report_results('ECALL unsupported call', self.options.svcomp)
                sys.exit(1)

            self.prepare()
            self.libs = get_libraries(opts.is32bit, opts.add_libc)
            if not self.libs:
                err('Failed compiling support library')

            self.link()
            self.optimize(passes=['-simplifycfg', '-constprop'])
            if not self.options.noslice:
                self.slicer(criterion)
                self.optimize()

        except SymbioticException as e:
            # FIXME if we should not run further, do not run further
            err('Failure >> {0}'.format(e.message))

        found = run_symexe(self.llvmfile)
        return report_results(found, self.options.svcomp)

def generate_graphml(path, saveto):
    if saveto is None:
        saveto = '{0}.graphml'.format(os.path.basename(path))
        saveto = os.path.abspath(saveto)

    dbg('Generating counterexample: {0}'.format(saveto))
    bindir = os.path.dirname(sys.argv[0])
    f = open('/dev/null', 'r')
    ret = call(['{0}/path_to_ml.pl {1} > {2}'.format(bindir, path, saveto)],
               shell=True, stdout = f, stderr = f)
    if ret != 0:
        dbg('Generating witness failed')

def generate_counterexample(bindir, saveto = None):
    abd = os.path.abspath(bindir)
    for path in os.listdir('{0}/klee-last'.format(abd)):
        if 'assert' in path:
            pth = os.path.abspath('{0}/klee-last/{1}.path'.format(abd, path[:-11]))
            generate_graphml(pth, saveto)
            break

def get_prp(prp):
    # if property is given in file, read the file
    epath = os.path.expanduser(prp)
    if os.path.isfile(epath):
        f = open(epath, 'r')
        prp = f.readline().strip()
        f.close()

    return prp

def check_property(prp):
    if prp is None:
        return True

    for r in supported_properties.values():
        if prp == r:
            return True

    return False

def parse_command_line():
    options = SymbioticOptions()

    try:
        opts, args = getopt.getopt(sys.argv[1:], '',
                                   ['no-slice', '64', 'prp=',
                                    'debug=', 'timeout=', 'sv-comp', 'version',
                                    'libc=', 'old-slicer', 'require-slicer'])
                                   # add klee-params
    except getopt.GetoptError as e:
        err('{0}'.format(str(e)))

    for opt, arg in opts:
        if opt == '--debug':
            global enable_debug
            enable_debug = True
            parse_debug_opts(arg)
        elif opt == '--libc':
             if arg == 'klee':
                 options.add_libc = True
             else:
                 print('Unknown libc')
                 sys.exit(0)
        elif opt == '--version':
            print(VERSION)
            sys.exit(0)
        elif opt == '--no-slice':
            dbg('Will not slice')
            options.noslice = True
        elif opt == '--require-slicer':
            options.require_slicer = True
        elif opt == '--old-slicer':
            dbg('Will use old slicer')
            options.old_slicer = True
        elif opt == '--64':
            dbg('Will use 64-bit environment')
            options.is32bit = False
        elif opt == '--prp':
            options.prp = get_prp(arg)
            dbg('Property: {0}'.format(options.prp))
        elif opt == '--timeout':
            options.timeout = int(arg)
            dbg('Timeout set to {0} sec'.format(arg))
        elif opt == '--sv-comp':
            dbg('Output format is sv-comp')
            options.svcomp = True

    return options, args

if __name__ == "__main__":
    opts, args = parse_command_line()
    #set_environ(opts.is32bit)
    if len(args) != 1:
        err(usage_msg)

    source = args[0]

    if opts.timeout != 0:
        start_timeout(opts.timeout)

    try:
        if not check_property(opts.prp):
            report_results('EPRP usupported property', opts.svcomp)
            sys.exit(1)

        symbiotic = Symbiotic(source, opts)
        res = symbiotic.run()

        if res == 'FALSE' or res == 'ASSERTIONFAILED':
            srcdir = os.path.dirname(source)
            saveto = '{0}/{1}.graphml'.format(os.path.abspath(srcdir),
                                              os.path.basename(source))
            generate_counterexample(srcdir, saveto)
    except Timeout:
        sys.stdout.flush()
        sys.stderr.flush()
        if not current_process is None:
            current_process.terminate()
            current_process.kill()

        report_results('TIMEOUT', opts.svcomp)
    finally:
        stop_timeout()
        sys.stderr.flush()
        sys.stdout.flush()

    sys.exit(0)
