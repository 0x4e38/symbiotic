#!/usr/bin/env python
#
#  -- Symbiotic tool --
#
#   Author: Marek Chalupa <mchqwerty@gmail.com>
#           2015 - 2016
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.

import sys
import os
import getopt
from time import time

# set path to our package
pth = os.path.join(os.path.dirname(__file__), 'lib/symbioticpy')
sys.path.append(os.path.abspath(pth))

from symbiotic.utils import err, dbg, enable_debug
from symbiotic.utils.utils import print_stdout, print_stderr, get_symbiotic_dir
from symbiotic.utils.watch import ProcessWatch
from symbiotic.utils.timeout import Timeout, start_timeout, stop_timeout
from symbiotic.utils.process import ProcessRunner
from symbiotic import SymbioticException, Symbiotic
from symbiotic.options import SymbioticOptions
from symbiotic.witnesses.witnesses import GraphMLWriter

from subprocess import call

# FIXME print versions of components too
VERSION='3.0.5-dev'

usage_msg = """
Usage: symbiotic OPTS sources

where OPTS can be following:

    --bc                      Given file is a bytecode
    --64                      Use 64-bit environment
    --timeout=t               Set timeout to t seconds
    --no-slice                Do not slice the code
    --no-prepare              Do not prepare the code
    --explicit-symbolic       Do not make all memory symbolic (in prepare phase),
                              but rely on calls to __VERIFIER_nondet_*
    --undefined-retval-nosym  Do not make return value of undefined functions symbolic,
                              but replace it with 0.
    --malloc-never-fails      Suppose malloc and calloc never return NULL
    --require-slicer          Abort if slicing fails (default is to use the original file)
    --no-symexe               Do not run symbolic execution (handy for debugging)
    --optimize=TYPES          Run optimizations, TYPES can be: before, before-O2, after.
                              before/after means before or/and after slicing. before-O2
                              runs full list of optimizations before slicing (normally only
                              some conservative optimizations are run before slicing).
                              none disables optimizations (same as --no-optimize).
                              When opt-O2 is given, then opt is called with -O2
                              switch instead of the list of our optimizations.
    --no-optimize             Don't optimize the code (same as --optimize=none)
    --libc=klee               Link klee-libc.bc to the module
    --no-lib                  Don't link lib.bc to the module
    --slicing-criterion=C     Slice to slicing criterion (function call-sites) 'C'
                              (default is '__assert_fail')
    --repeat-slicing=N        Repeat slicing N times
    --prp=property            Specify property that should hold. It is either LTL formula
                              as specivied by SV-COMP, or one of following shortcuts:
                                null-deref   -- program is free of null-dereferences
                                valid-deref  -- all dereferences are valid
                                valid-free   -- all free() calls are valid
                              The string can be given on line or in a file.
    --pta=[fs|fi|old]         Use flow-sensitive/flow-insensitive or old
                              (flow-insensitive too) points-to analysis when slicing.
                              Default is the old
    --debug=what              Print debug messages, what can be comma separated list of:
                              all, compile, prepare, slicer
                              In that case you get verbose output. You can just use
                              --debug= to print basic messages.
    --output=FILE             Store the final code (that is to be run by symexe) to FILE
    --witness=FILE            Store witness into FILE (default is witness.graphml)
    --cflags=flags
    --cppflags=flags          Append extra CFLAGS and CPPFLAGS to use while compiling,
                              the environment CFLAGS and CPPFLAGS are used too
    --slicer-params=STR       Pass parameters directly to slicer
    --symexe-params=STR       Pass parameters directly to symbolic executor
    --help                    Show help message
    --version                 Return version

    One (and only one) of the sources must contain 'main' function
"""

supported_properties = {
    'CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )' : 'REACHCALL',
    'CHECK( init(main()), LTL(G valid-free) )'                 : 'VALID-FREE',
    'CHECK( init(main()), LTL(G valid-deref) )'                : 'VALID-DEREF',
    'CHECK( init(main()), LTL(G valid-memtrack) )'             : 'MEM-TRACK',
    'valid-deref'                                              : 'VALID-DEREF',
    'valid-free'                                               : 'VALID-FREE',
    'valid-memtrack'                                           : 'MEM-TRACK',
    'null-deref'                                               : 'NULL-DEREF',
}


def get_include_paths():
    """
    Find paths where standard headers are located
    """
    cmd = ['find', '/usr/lib', '-name', 'stddef.h']
    paths = []

    pr = ProcessRunner(cmd, ProcessWatch(lines_limit = None))
    if pr.run() == 0:
        for line in pr.getOutput():
            if line.startswith('/usr/lib/'):
                paths.append(os.path.dirname(line))

    return paths

def set_environ(is32bit = False):
    def prepend(env, what):
        if os.environ.has_key(env):
            newenv = '{0}:{1}'.format(what, os.environ[env])
        else:
            newenv = what

        os.environ[env] = newenv

    # do this before we override PATH - we need 'find' utility
    additional_paths = get_include_paths()
    for p in additional_paths:
        prepend('C_INCLUDE_DIR', p)

    symbiotic_dir = get_symbiotic_dir()
    # set path without preprending, we want to use only our stuff
    os.environ['PATH'] = '{0}/bin'.format(symbiotic_dir)
    prepend('LD_LIBRARY_PATH', '{0}/lib'.format(symbiotic_dir))
    prepend('C_INCLUDE_DIR', '{0}/include'.format(symbiotic_dir))

    if is32bit:
        os.environ['KLEE_RUNTIME_LIBRARY_PATH'] = '{0}/lib32/klee/runtime'.format(symbiotic_dir)
    else:
        os.environ['KLEE_RUNTIME_LIBRARY_PATH'] = '{0}/lib/klee/runtime'.format(symbiotic_dir)

    dbg('PATH={0}'.format(os.environ['PATH']))
    dbg('LD_LIBRARY_PATH={0}'.format(os.environ['LD_LIBRARY_PATH']))
    dbg('C_INCLUDE_DIR={0}'.format(os.environ['C_INCLUDE_DIR']))

def parse_environ(opts):
    """
    Parse environment variables of interest and
    change running options accordingly
    """
    for p in os.environ['C_INCLUDE_DIR'].split(':'):
        opts.CPPFLAGS.append('-I{0}'.format(p))

    if os.environ.has_key('CFLAGS'):
        opts.CFLAGS += os.environ['CFLAGS'].split(' ')
    if os.environ.has_key('CPPFLAGS'):
        opts.CPPFLAGS += os.environ['CPPFLAGS'].split(' ')

def generate_graphml(path, saveto):
    if saveto is None:
        saveto = '{0}.graphml'.format(os.path.basename(path))
        saveto = os.path.abspath(saveto)

    dbg('Generating counterexample: {0}'.format(saveto), domain='witness')
    gen = GraphMLWriter()
    gen.parsePath(path)
    gen.write(saveto)

def generate_counterexample(bindir, saveto = None):
    abd = os.path.abspath(bindir)
    for path in os.listdir('{0}/klee-last'.format(abd)):
        if 'assert' in path:
            pth = os.path.abspath('{0}/klee-last/{1}.path'.format(abd, path[:-11]))
            generate_graphml(pth, saveto)
            break

def get_prp(prp):
    # if property is given in file, read the file
    epath = os.path.expanduser(prp)
    if os.path.isfile(epath):
        prp_list = []
        f = open(epath, 'r')
        for line in f.readlines():
            line = line.strip()
            # ignore empty lines
            if line:
                prp_list.append(line)
        f.close()
        return prp_list

    # it is not a file, so it is given as a string
    # FIXME: this does not work for properties given
    # as LTL (there are spaces)
    return prp.split()

def parse_command_line():
    options = SymbioticOptions()

    try:
        opts, args = getopt.getopt(sys.argv[1:], '',
                                   ['no-slice', '64', 'prp=', 'no-optimize',
                                    'debug=', 'timeout=', 'version', 'help',
                                    'libc=', 'old-slicer', 'require-slicer',
                                    'no-symexe', 'output=', 'witness=', 'bc',
                                    'optimize=', 'no-prepare', 'malloc-never-fails',
                                    'pta=', 'no-lib', 'slicing-criterion=',
                                    'cflags=', 'cppflags=', 'link=',
                                    'no-link-undefined', 'repeat-slicing=',
                                    'slicer-params=', 'symexe-params=',
                                    'explicit-symbolic', 'undefined-retval-nosym'])
                                   # add klee-params
    except getopt.GetoptError as e:
        err('{0}'.format(str(e)))

    for opt, arg in opts:
        if opt == '--help':
            print(usage_msg)
            sys.exit(0)
        elif opt == '--debug':
            enable_debug(arg.split(','))
        elif opt == '--libc':
             if arg == 'klee':
                 options.add_libc = True
             else:
                 print('Unknown libc')
                 sys.exit(0)

        elif opt == '--no-lib':
            dbg('Won\'t link lib.bc to the module')
            options.no_lib = True
        elif opt == '--version':
            print(VERSION)
            sys.exit(0)
        elif opt == '--no-slice':
            dbg('Will not slice')
            options.noslice = True
        elif opt == '--no-prepare':
            dbg('Will not prepare code')
            options.noprepare = True
        elif opt == '--explicit-symbolic':
            options.explicit_symbolic = True
        elif opt == '--undefined-retval-nosym':
            options.undef_retval_nosym = True
        elif opt == '--no-link-undefined':
            dbg('Will not try to find and link undefined functions')
            options.nolinkundef = True
        elif opt == '--malloc-never-fails':
            dbg('Assuming malloc and calloc will never fail')
            options.malloc_never_fails = True
        elif opt == '--no-symexe':
            dbg('Will not run symbolic execution')
            options.no_symexe = True
        elif opt == '--require-slicer':
            options.require_slicer = True
        elif opt == '--old-slicer':
            dbg('Will use old slicer')
            options.old_slicer = True
        elif opt == '--64':
            dbg('Will use 64-bit environment')
            options.is32bit = False
        elif opt == '--no-optimize':
            dbg('Will not optimize the code')
            options.no_optimize = True
        elif opt == '--optimize':
            dbg('Optimization levels: ' + arg)
            options.optlevel = arg.split(',')
            for o in options.optlevel:
                o = o.strip()
                if o == "none":
                    options.no_optimize = True
                    options.optlevel = []
                    break
                if not o in ["before", "after", "before-O2", "none", "opt-O2"]:
                    err('Unknown optimization level, try --help')
        elif opt == '--prp':
            options.prp = get_prp(arg)
            for prp in options.prp:
                dbg('Property: {0}'.format(prp))
        elif opt == '--pta':
            options.slicer_pta = arg
            if not arg in ['fs', 'fi', 'old']:
                err('Points-to analysis can be one of: fs, fi, old')

            dbg('Points-to: {0}'.format(arg))
        elif opt == '--slicing-criterion':
            options.slicing_criterion = arg
            dbg('Slicing criterion: {0}'.format(arg))
        elif opt == '--repeat-slicing':
            try:
                options.repeat_slicing = int(arg)
            except ValueError:
                err('Invalid argument for --repeat-slicing')
            dbg('Will repeat slicing {0} times'.format(arg))
        elif opt == '--timeout':
            options.timeout = int(arg)
            dbg('Timeout set to {0} sec'.format(arg))
        elif opt == '--output':
            options.final_output = arg
            dbg('Output will be stored to {0}'.format(arg))
        elif opt == '--witness':
            options.witness_output = arg
            dbg('Witness will be stored to {0}'.format(arg))
        elif opt == '--bc':
            options.source_is_bc = True
            dbg('Given code is bytecode')
        elif opt == '--cflags':
            global CFLAGS
            CFLAGS += arg.split()
        elif opt == '--cppflags':
            global CPPFLAGS
            CPPFLAGS += arg.split()
        elif opt == '--slicer-params':
            options.slicer_params = arg.split()
        elif opt == '--symexe-params':
            options.symexe_params = arg.split()
        elif opt == '--link':
            options.link_files += arg.split(',')

    return options, args

if __name__ == "__main__":
    # store time when we have started, so that we can
    # measure how long Symbiotic ran
    start_time = time()

    opts, args = parse_command_line()
    if len(args) < 1:
        print(usage_msg)
        sys.exit(1)

    sources = args
    if opts.source_is_bc and len(sources) != 1:
        err('Bytecode must be only one file')

    if opts.timeout != 0:
        start_timeout(opts.timeout)

    symbiotic = None

    try:
        try:
            # opts.prp now contain a list with keys (or None),
            # but we want the value from the map
            if opts.prp:
                prps = opts.prp[:] # make copy of properties
                opts.prp = []

                for prp in prps:
                    prp_key = supported_properties[prp]
                    opts.prp.append(prp_key)

                    # for some properties we need to modify
                    # parsing of the output
                    if prp_key == 'VALID-DEREF':
                        # we don't know to which locations
                        # we should slice, so suspend the slicing
                        # for now
                        dbg('Will not slice due to VALID-DEREF property')
                        opts.noslice = True
        except KeyError as ke:
            err('Unknown or unsupported property: {0}'.format(ke.message))

        # set environment. That is set PATH and LD_LIBRARY_PATH
        # and so on
        set_environ(opts.is32bit)
        # set CFLAGS and CPPFLAGS for compilation
        parse_environ(opts)

        # let the show begin!
        try:
            symbiotic = Symbiotic(sources, opts)
            res = symbiotic.run()
        except SymbioticException as e:
            if e.message:
                print('RESULT: ERROR ({0})'.format(e.message))
            else:
                print('RESULT: ERROR (unknown)')

            sys.stdout.flush()
            sys.stderr.flush()

            err(' == FAILURE ==\n{0}'.format(e.message))

        if res == 'FALSE' or res == 'ASSERTIONFAILED':
            srcdir = os.path.dirname(symbiotic.llvmfile)
            generate_counterexample(srcdir, opts.witness_output)
    except Timeout:
        if symbiotic:
            symbiotic.terminate()
            symbiotic.kill()

        sys.stdout.flush()
        sys.stderr.flush()

        print('TIMEOUT')
    finally:
        stop_timeout()

    # print information about how long Symbiotic ran
    print('INFO: Total time elapsed: {0}'.format(time() - start_time))
    sys.exit(0)
