#!/usr/bin/env python

import sys
import os
import re
import getopt
import signal
from subprocess import call, Popen, PIPE, STDOUT

# define and compile regular expressions for parsing klee's output
patterns = {
    'ASSERTIONFAILED' : re.compile('.*ASSERTION FAIL: verifier assertion failed.*'),
    'ESTPTIMEOUT' : re.compile('.*query timed out (resolve).*'),
    'EKLEETIMEOUT' : re.compile('.*HaltTimer invoked.*'),
    'EEXTENCALL' : re.compile('.*failed external call.*'),
    'ELOADSYM' : re.compile('.*ERROR: unable to load symbol.*'),
    'EINVALINST' : re.compile('.*LLVM ERROR: Code generator does not support.*'),
    'EKLEEASSERT' : re.compile('.*klee: .*Assertion .* failed.*'),
    'EINITVALS' : re.compile('.*unable to compute initial values.*'),
    'ESYMSOL' : re.compile('.*unable to get symbolic solution.*'),
    'ESLIENTLYCONCRETIZED' : re.compile('.*silently concretizing.*'),
    'EEXTRAARGS' : re.compile('.*calling .* with extra arguments.*'),
    'EABORT' : re.compile('.*abort failure.*'),
    'EGENERAL' : re.compile('.*now ignoring this error at this location.*')
}

supported_properties = {
    'REACHCALL'  : 'CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )'
}

unsupported_call = re.compile('.*call to .* is unsupported.*')

enable_debug = False
got_error = False
# this is global variable for currently running
# klee process, so that we can kill it if we need
# (e. g. on timeout)
klee_process = None

class Timeout(Exception):
    pass

def start_timeout(sec):
    def alarm_handler(signum, data):
        raise Timeout

    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(sec)

def stop_timeout():
    # turn of timeout
    signal.signal(signal.SIGALRM, signal.SIG_DFL)
    signal.alarm(0)

def run_and_watch(cmd, watch):
    dbg(' '.join(cmd))
    process = Popen(cmd, stdout=PIPE, stderr=STDOUT)

    while True:
        line = process.stdout.readline()
        if line == '' and process.poll() is not None:
            break

        if not watch(line):
            process.terminate()
            process.kill()
            return -1

    process.wait()
    return process.returncode

def print_svcomp(what):
    if what == 'ASSERTIONFAILED':
        print('FALSE')
    elif what[0] == 'E':
        got_error = True
        print('UNKNOWN')

def get_match(line):
    for (key, pattern) in patterns.iteritems():
        if pattern.match(line):
            # return True so that we know we should terminate
            if key == 'ASSERTIONFAILED':
                return (key, True)
            else:
                return (key, False)

    return (None, False)

def print_stderr(msg, prefix = None, print_newline = True):
    if msg == '':
        return
    if not prefix is None:
        sys.stderr.write(prefix)

    sys.stderr.write(msg)
    if print_newline:
        sys.stderr.write('\n')

    sys.stderr.flush()

def err(msg):
    print_stderr(msg, 'ERR: ')
    sys.exit(1)

def dbg(msg, print_newline = True):
    if enable_debug:
        print_stderr(msg, 'DBG: ', print_newline)

def get_symbiotic_dir():
    return os.path.abspath(os.path.dirname(sys.argv[0]))

def set_environ(is32bit = False):
    def prepend(env, what):
        if os.environ.has_key(env):
            newenv = '{0}:{1}'.format(what, os.environ[env])
        else:
            newenv = what

        os.environ[env] = newenv

    symbiotic_dir = get_symbiotic_dir()
    # set path without preprending, we want to use only our stuff
    os.environ['PATH'] = '{0}/bin'.format(symbiotic_dir)
    prepend('LD_LIBRARY_PATH', '{0}/lib'.format(symbiotic_dir))
    prepend('C_INCLUDE_DIR', '{0}/include'.format(symbiotic_dir))
    if is32bit:
        prepend('KLEE_RUNTIME_LIBRARY_PATH',
                '{0}/lib32/klee/runtime'.format(symbiotic_dir))
    else:
        prepend('KLEE_RUNTIME_LIBRARY_PATH',
                '{0}/lib/klee/runtime'.format(symbiotic_dir))

    dbg(os.environ['PATH'])
    dbg(os.environ['LD_LIBRARY_PATH'])

def compile_to_llvm(source, is32bit = False, output = None):
    symbiotic_dir = get_symbiotic_dir()

    cmd = ['clang', '-c', '-emit-llvm', '-I']
    cmd.append('{0}/include'.format(symbiotic_dir))

    if is32bit:
        cmd.append('-m32')

    cmd.append('-o')
    if output is None:
        llvmfile = '{0}.bc'.format(source[:source.rfind('.')])
    else:
        llvmfile = output

    cmd.append(llvmfile)

    dbg(os.environ['PATH'])
    dbg(os.environ['LD_LIBRARY_PATH'])

def dbg_watch(l):
    dbg(l, False)
    return True

def compile_to_llvm(source, is32bit = False, output = None):
    symbiotic_dir = get_symbiotic_dir()

    cmd = ['clang', '-c', '-emit-llvm', '-I']
    cmd.append('{0}/include'.format(symbiotic_dir))
    cmd.append('-include')
    cmd.append('{0}/include/symbiotic.h'.format(symbiotic_dir))

    if is32bit:
        cmd.append('-m32')

    cmd.append('-o')
    if output is None:
        llvmfile = '{0}.bc'.format(source[:source.rfind('.')])
    else:
        llvmfile = output

    cmd.append(llvmfile)
    cmd.append(source)

    if run_and_watch(cmd, dbg_watch) != 0:
        return None

    return llvmfile

def instrument(source):
    sd = get_symbiotic_dir()
    cmd = ['/bin/sh', '-c', '{0}/build-fix.sh {1}'.format(sd, source)]
    if run_and_watch(cmd, dbg_watch) != 0:
        return None

    # we're instrumenting right into the source
    return source

def prepare(src, svcomp):
    if not svcomp:
        return src

    output = '{0}-prepared.bc'.format(src[:src.rfind('.')])
    cmd = ['opt', '-load', 'LLVMsvc13.so', '-prepare', '-delete-undefined',
           src, '-o', output]

    if run_and_watch(cmd, dbg_watch) != 0:
        return None

    return output

def get_verifier_funcs(is32bit = False):
    symbiotic_dir = get_symbiotic_dir()
    if is32bit:
        libbc = '{0}/lib32/lib.bc'.format(symbiotic_dir)
    else:
        libbc = '{0}/lib/lib.bc'.format(symbiotic_dir)

    libc = '{0}/lib.c'.format(symbiotic_dir)
    return compile_to_llvm(libc, is32bit, libbc)

def link(llvmfile, lib):
    output = '{0}-linked.bc'.format(source[:source.rfind('.')])
    cmd = ['llvm-link', llvmfile, lib, '-o', output]

    if run_and_watch(cmd, dbg_watch) != 0:
        return None

    return output

def slicer(llvmfile, criterion):
    output = '{0}.sliced'.format(llvmfile[:llvmfile.rfind('.')])
    cmd = ['llvm-slicer', '-c', criterion, llvmfile]

    if run_and_watch(cmd, dbg_watch) != 0:
        return None

    return output

def unsupp_watch(line):
    dbg(line, False)
    return not unsupported_call.match(line)

def check_llvmfile(llvmfile):
    cmd = ['opt', '-load', 'LLVMsvc13.so', '-check-unsupported',
           '-o', '/dev/null', llvmfile]
    if run_and_watch(cmd, unsupp_watch) == -1:
        return False

    return True

def parse_klee_output(line):
    dbg(line, False)
    return get_match(line)

def run_symexe(llvmfile):
    cmd = ['klee', '-optimize', llvmfile]
    dbg(str(cmd))

    global klee_process
    klee_process = Popen(cmd, stdout=PIPE, stderr=STDOUT)

    found = ''
    while True:
        line = klee_process.stdout.readline()
        if line == '' and klee_process.poll() is not None:
            break

        nxt, done = parse_klee_output(line)

        if done:
            klee_process.terminate()
            klee_process.kill()
	    found = nxt
            break
        elif not nxt is None:
            found += '{0} '.format(nxt)

    klee_process.wait()
    return found

def get_prp(prp):
    # if property is given in file, read the file
    epath = os.path.expanduser(prp)
    if os.path.isfile(epath):
        f = open(epath, 'r')
        prp = f.readline().strip()
        f.close()

    return prp

def check_property(prp):
    if prp is None:
        return True

    for r in supported_properties.values():
        if prp == r:
            return True

    return False

class Options(object):
    def __init__(self, is32bit = True, noslice=False, prp=None, svcomp = False, timeout=0):
        self.is32bit = is32bit
        self.prp = prp
        self.noslice = noslice
        self.svcomp = svcomp
        self.timeout = 0

def parse_command_line():
    options = Options()

    try:
        opts, args = getopt.getopt(sys.argv[1:], '',
                                   ['no-slice', '64', 'prp=',
                                    'debug', 'timeout=', 'sv-comp'])
                                   # add klee-params
    except getopt.GetoptError as e:
        err('{0}'.format(str(e)))

    for opt, arg in opts:
        if opt == '--debug':
            dbg('debug enabled')
            global enable_debug
            enable_debug = True
        elif opt == '--no-slice':
            dbg('Will not slice')
            options.noslice = True
        elif opt == '--64':
            dbg('Will use 64-bit environment')
            options.is32bit = False
        elif opt == '--prp':
            options.prp = get_prp(arg)
            dbg('Property: {0}'.format(options.prp))
        elif opt == '--timeout':
            options.timeout = int(arg)
            dbg('Timeout set to {0} sec'.format(arg))
        elif opt == '--sv-comp':
            dbg('Output format is sv-comp')
            options.svcomp = True

    return options, args

def report_results(res, svcomp):
    dbg(res)
    if svcomp:
        if res.startswith('ASSERTIONFAILED'):
            print('FALSE')
        elif res == '':
            print('TRUE')
        elif res == 'TIMEOUT':
            print('TIMEOUT')
        else:
            print('UNKNOWN')
    else:
        print(res)

    sys.stdout.flush()

def do_it(source, opts):
    instrumented = instrument(source)
    if instrumented is None:
        err('Failed instrumenting the code')

    # set environ here, because in instrumentation we use
    # grep and similar commands
    # FIXME rewrite instrumentation here
    set_environ(opts.is32bit)

    llvmfile = compile_to_llvm(instrumented, opts.is32bit)
    if llvmfile is None:
        err('Failed compiling the source {0}'.format(source))

    if not check_llvmfile(llvmfile):
        report_results('ECALL unsupported call', opts.svcomp)
        sys.exit(1)

    prepared = prepare(llvmfile, opts.svcomp)
    if prepared is None:
        err('Failed preparing the llvm file')

    lib = get_verifier_funcs(opts.is32bit)
    if lib is None:
        err('Failed compiling support library')

    linkedfile = link(prepared, lib)
    if linkedfile is None:
        err('Failed linking library with source')

    if opts.noslice:
        slicedfile = None
    else:
        slicedfile = slicer(linkedfile, '__assert_fail')
        if slicedfile is None:
            dbg("Slicing failed, using original file")

    if slicedfile is None:
        found = run_symexe(linkedfile)
    else:
        found = run_symexe(slicedfile)

    report_results(found, opts.svcomp)


if __name__ == "__main__":
    opts, args = parse_command_line()
    #set_environ(opts.is32bit)
    if len(args) != 1:
        err('Usage: symbiotic [--64 | --timeout=t | --no-slice | prp=property] source')

    source = args[0]

    if opts.timeout != 0:
        start_timeout(opts.timeout)

    try:
        if not check_property(opts.prp):
            report_results('EPRP usupported property', opts.svcomp)
            sys.exit(1)

        do_it(source, opts)
    except Timeout:
        sys.stdout.flush()
        sys.stderr.flush()
	if not klee_process is None:
            klee_process.terminate()
            klee_process.kill()

        report_results('TIMEOUT', opts.svcomp)
    finally:
        stop_timeout()

    sys.stderr.flush()
    sys.stdout.flush()
    sys.exit(0)
